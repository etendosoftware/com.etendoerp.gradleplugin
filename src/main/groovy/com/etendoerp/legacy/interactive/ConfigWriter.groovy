package com.etendoerp.legacy.interactive

import org.gradle.api.Project
import java.util.regex.Pattern

/**
 * Handles writing configuration properties to gradle.properties file.
 * 
 * This class is responsible for:
 * - Preserving existing comments and file structure
 * - Updating property values while maintaining format
 * - Creating gradle.properties if it doesn't exist
 * - Handling empty values and special characters properly
 * 
 * @author Etendo Interactive Setup Team
 * @since 2.0.4
 */
class ConfigWriter {
    
    private final Project project
    private static final String GRADLE_PROPERTIES_FILE = "gradle.properties"
    private static final String BACKUP_SUFFIX = ".backup"
    private static final String TEMP_SUFFIX = ".tmp"
    
    /**
     * Creates a new ConfigWriter for the given project.
     * 
     * @param project The Gradle project context
     */
    ConfigWriter(Project project) {
        this.project = project
    }
    
    /**
     * Writes the provided properties to gradle.properties file.
     * 
     * This method:
     * 1. Creates a backup of the existing file if it exists
     * 2. Preserves existing comments and structure
     * 3. Updates existing property values
     * 4. Adds new properties at the end
     * 5. Handles the write operation atomically using a temporary file
     * 
     * @param properties Map of property keys to values to write
     * @throws RuntimeException if the write operation fails
     */
    void writeProperties(Map<String, String> properties) {
        if (!properties) {
            project.logger.info("No properties to write")
            return
        }
        
        def gradlePropsFile = project.file(GRADLE_PROPERTIES_FILE)
        project.logger.debug("Writing ${properties.size()} properties to ${gradlePropsFile.absolutePath}")
        
        try {
            // Create backup if file exists
            if (gradlePropsFile.exists()) {
                createBackup(gradlePropsFile)
            }
            
            // Merge properties with existing content
            def newContent = mergePropertiesWithExisting(gradlePropsFile, properties)
            
            // Write atomically using temporary file
            writeContentAtomically(gradlePropsFile, newContent)
            
            project.logger.info("Successfully wrote configuration to ${GRADLE_PROPERTIES_FILE}")
            
        } catch (Exception e) {
            project.logger.error("Failed to write properties to ${GRADLE_PROPERTIES_FILE}: ${e.message}", e)
            throw new RuntimeException("Configuration write failed", e)
        }
    }
    
    /**
     * Merges new properties with existing file content, preserving comments and structure.
     * 
     * @param gradlePropsFile The gradle.properties file
     * @param newProperties Properties to merge in
     * @return List of lines representing the merged content
     */
    private List<String> mergePropertiesWithExisting(File gradlePropsFile, Map<String, String> newProperties) {
        def existingLines = gradlePropsFile.exists() ? gradlePropsFile.readLines() : []
        
        if (existingLines.isEmpty()) {
            // No existing file, create new content
            return createNewFileContent(newProperties)
        } else {
            // Merge with existing content
            return mergePropertiesWithComments(existingLines, newProperties)
        }
    }
    
    /**
     * Creates content for a new gradle.properties file.
     * 
     * @param properties Properties to include
     * @return List of lines for the new file
     */
    private List<String> createNewFileContent(Map<String, String> properties) {
        def lines = []
        
        // Add header comment
        lines.add("# Etendo Project Configuration")
        lines.add("# Generated by Interactive Setup on ${new Date()}")
        lines.add("")
        
        // Group properties and add them
        def groupedProps = groupPropertiesForWriting(properties)
        
        groupedProps.each { group, props ->
            if (group != "General") {
                lines.add("# ${group} Configuration")
            }
            
            props.sort().each { key, value ->
                lines.add("${key}=${value}")
            }
            lines.add("") // Empty line between groups
        }
        
        return lines
    }
    
    /**
     * Merges new properties with existing file content while preserving comments.
     * 
     * @param existingLines Current file content as lines
     * @param newProperties Properties to merge
     * @return Merged content as lines
     */
    private List<String> mergePropertiesWithComments(List<String> existingLines, Map<String, String> newProperties) {
        def result = []
        def processedProperties = new HashSet<String>()
        def propertyPattern = Pattern.compile('^\\s*([^#=\\s][^=]*)\\s*=\\s*(.*)$')
        
        // Process existing lines
        for (String line : existingLines) {
            def matcher = propertyPattern.matcher(line)
            
            if (matcher.matches()) {
                // Property line
                def key = matcher.group(1).trim()
                
                if (newProperties.containsKey(key)) {
                    // Update with new value
                    def newValue = newProperties[key]
                    result.add("${key}=${newValue}")
                    processedProperties.add(key)
                    project.logger.debug("Updated property: ${key}")
                } else {
                    // Keep existing line unchanged
                    result.add(line)
                }
            } else {
                // Comment or empty line - preserve as-is
                result.add(line)
            }
        }
        
        // Add new properties that weren't in the existing file
        def unprocessedProperties = newProperties.keySet() - processedProperties
        
        if (!unprocessedProperties.isEmpty()) {
            // Add separator if file doesn't end with empty line
            if (!result.isEmpty() && !result.last().trim().isEmpty()) {
                result.add("")
            }
            
            result.add("# Properties added by Interactive Setup")
            
            unprocessedProperties.sort().each { key ->
                def value = newProperties[key]
                result.add("${key}=${value}")
                project.logger.debug("Added new property: ${key}")
            }
        }
        
        return result
    }
    
    /**
     * Groups properties by category for organized writing.
     * For now, this is a simple implementation - could be enhanced with
     * actual property metadata in the future.
     */
    private Map<String, Map<String, String>> groupPropertiesForWriting(Map<String, String> properties) {
        def groups = [:]
        
        properties.each { key, value ->
            def group = determinePropertyGroup(key)
            if (!groups[group]) {
                groups[group] = [:]
            }
            groups[group][key] = value
        }
        
        return groups
    }
    
    /**
     * Determines the group/category for a property based on its key.
     */
    private String determinePropertyGroup(String key) {
        if (key.startsWith("bbdd.") || key.startsWith("db.")) {
            return "Database"
        } else if (key.contains("password") || key.contains("token") || key.contains("secret")) {
            return "Security"
        } else if (key.contains("path") || key.contains("dir")) {
            return "Paths"
        } else {
            return "General"
        }
    }
    
    /**
     * Writes content to file atomically using a temporary file.
     * 
     * @param targetFile The final target file
     * @param content Content to write as lines
     */
    private void writeContentAtomically(File targetFile, List<String> content) {
        def tempFile = new File(targetFile.parentFile, targetFile.name + TEMP_SUFFIX)
        
        try {
            // Write to temporary file first
            tempFile.withWriter { writer ->
                content.each { line ->
                    writer.writeLine(line)
                }
            }
            
            // Atomic move (rename) to final location
            if (targetFile.exists()) {
                targetFile.delete()
            }
            
            if (!tempFile.renameTo(targetFile)) {
                throw new IOException("Failed to rename temporary file to ${targetFile.name}")
            }
            
        } catch (Exception e) {
            // Clean up temporary file if something went wrong
            if (tempFile.exists()) {
                tempFile.delete()
            }
            throw e
        }
    }
    
    /**
     * Creates a backup of the existing gradle.properties file.
     * 
     * @param originalFile The file to backup
     */
    private void createBackup(File originalFile) {
        def timestamp = new Date().format("yyyyMMdd-HHmmss")
        def backupFile = new File(originalFile.parentFile, "${originalFile.name}${BACKUP_SUFFIX}.${timestamp}")
        
        try {
            originalFile.withInputStream { input ->
                backupFile.withOutputStream { output ->
                    output << input
                }
            }
            
            project.logger.info("Created backup: ${backupFile.name}")
            
        } catch (Exception e) {
            project.logger.warn("Failed to create backup of ${originalFile.name}: ${e.message}")
            // Don't fail the entire operation just because backup failed
        }
    }
    
    /**
     * Validates that the properties can be safely written.
     * 
     * @param properties Properties to validate
     * @return true if validation passes
     * @throws IllegalArgumentException if validation fails
     */
    boolean validateProperties(Map<String, String> properties) {
        if (!properties) {
            return true
        }
        
        // Check for null or empty keys
        def invalidKeys = properties.keySet().findAll { !it || it.trim().isEmpty() }
        if (!invalidKeys.isEmpty()) {
            throw new IllegalArgumentException("Found properties with empty or null keys: ${invalidKeys}")
        }
        
        // Check for keys containing problematic characters
        def problematicKeys = properties.keySet().findAll { key ->
            key.contains('\n') || key.contains('\r') || key.contains('=')
        }
        if (!problematicKeys.isEmpty()) {
            throw new IllegalArgumentException("Found property keys with invalid characters: ${problematicKeys}")
        }
        
        // Validate values (allow empty values, but not null)
        def nullValues = properties.findAll { key, value -> value == null }
        if (!nullValues.isEmpty()) {
            throw new IllegalArgumentException("Found properties with null values: ${nullValues.keySet()}")
        }
        
        return true
    }
    
    /**
     * Escapes special characters in property values for safe writing.
     * 
     * @param value The value to escape
     * @return Escaped value safe for properties file
     */
    private String escapePropertyValue(String value) {
        if (!value) return ""
        
        return value
            .replace('\\', '\\\\')  // Escape backslashes
            .replace('\n', '\\n')   // Escape newlines
            .replace('\r', '\\r')   // Escape carriage returns
            .replace('\t', '\\t')   // Escape tabs
    }
    
    /**
     * Gets information about the current state of gradle.properties file.
     * 
     * @return Map with file information
     */
    Map<String, Object> getFileInfo() {
        def gradlePropsFile = project.file(GRADLE_PROPERTIES_FILE)
        
        return [
            exists: gradlePropsFile.exists(),
            path: gradlePropsFile.absolutePath,
            size: gradlePropsFile.exists() ? gradlePropsFile.length() : 0,
            writable: gradlePropsFile.exists() ? gradlePropsFile.canWrite() : gradlePropsFile.parentFile.canWrite(),
            lastModified: gradlePropsFile.exists() ? new Date(gradlePropsFile.lastModified()) : null
        ]
    }
}
