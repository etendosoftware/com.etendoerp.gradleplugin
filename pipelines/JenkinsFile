def updateCommitStatus(repositoryName, status, description, accessToken, gitCommit, buildUrl, contextBuild) {
  sh "./pipelines/utils/build-update.sh ${repositoryName} ${status} \"${description}\" ${accessToken} ${gitCommit} ${buildUrl} \"${contextBuild}\""
}

def getLatestReleaseWithPrefix(String repo, String token, String prefix) {
    return sh(
        script: """
        set -e
        RESPONSE=\$(curl -s -w "%{http_code}" -H "Authorization: token ${token}" \\
            "https://api.github.com/repos/${repo}/releases?per_page=6")
        BODY=\$(echo "\$RESPONSE" | head -c -3)
        STATUS_CODE=\$(echo "\$RESPONSE" | tail -c 3)

        if [ "\$STATUS_CODE" -eq "401" ]; then
          echo "ERROR: Unauthorized. Please check your GitHub token permissions." >&2
          exit 1
        fi

        MATCH=\$(echo "\$BODY" | grep -o '"tag_name": *"${prefix}[^"]*"' | head -n 1 | sed -E 's/.*"([^"]+)"/\\1/')
        if [ -z "\$MATCH" ]; then
          echo "ERROR: No release found with prefix '${prefix}'." >&2
          exit 1
        fi

        echo "\$MATCH"
        """,
        returnStdout: true
    ).trim()
}

pipeline {
    environment {
        CONTEXT_NAME    = 'etendo'
        BBDD_SID        = 'etendo'
        BBDD_PORT       = '5432'
        BBDD_SYSTEMUSER = 'postgres'
        BBDD_SYSTEMPASS = 'syspass'
        BBDD_USER       = 'tad'
        BBDD_PASSWORD   = 'tad'
        NEXUS_USER      =  credentials('nexus-admin-user')
        NEXUS_PASSWORD  =  credentials('nexus-admin-passwd')
        GITHUB_USER     = 'etendobot'
        GITHUB_TOKEN    = credentials('github-read-package-token')

        EMAIL_ADDRESS   = credentials('email_builds')

        GITHUB_ORG      = 'etendosoftware'
        REPOSITORY_NAME = 'com.etendoerp.gradleplugin'
        GITHUB_URL      = 'https://github.com'
        ACCESS_TOKEN    = credentials('access_token_github')
        PLUGIN_URL      = " https://github.com/etendosoftware/com.etendoerp.gradleplugin.git"

        JAVA_HOME        = '/usr/lib/jvm/java-17-openjdk-amd64'
        POSTGRES_VERSION = '16'

        SUCCESS = 'SUCCESS'
        FAILED = 'FAILED'
        UNSTABLE = 'UNSTABLE'
        ABORTED = 'ABORTED'

        COMMIT_INPROGRESS_STATUS = 'pending'
        COMMIT_SUCCESS_STATUS    = 'success'
        COMMIT_FAILED_STATUS     = 'failure'

        CONTEXT_BUILD = 'Plugin Tests'

        RELEASE_PREFIX = '25'

        TRUE  = 'true'
        FALSE = 'false'

        MAIN_BRANCH   = 'main'
    }

    agent {
        kubernetes {
            inheritFrom 'jenkins-node-tests'
            defaultContainer 'jnlp'
            yamlFile 'pipelines/utils/AgentTests.yaml'
        }
    }

    stages {
        stage('Check Pipeline Skip Condition') { // MARK: Check Pipeline Skip Condition
            steps {
                script {
                    try {
                        echo "---------------------- Setting up Environment Variables ----------------------"
                        env.STATUS_TEST = SUCCESS // Overall status of the tests
                        env.JACOCO_REPORT_EXISTS = FALSE // Flag to indicate if Jacoco report exists
                        env.FAILED_SUITES = "" // List to collect failed test suites
                        
                        echo "--------------- Printenv ---------------"
                        sh 'printenv'

                        echo "--------------- Checking if pipeline should be skipped ---------------"
                        def changedFiles = sh(
                            script: "git diff --name-only HEAD~1 HEAD",
                            returnStdout: true
                        ).trim()
                            
                        echo "Files changed in last commit: ${changedFiles}"
                        
                        // Check if only JenkinsFileTestCompile was changed
                        def filesList = changedFiles.split('\n')
                        def onlyTestCompileJenkinsfile = filesList.every { it == "pipelines/JenkinsFileTestCompile" || it == "pipelines/utils/AgentTestCompile.yaml" } && filesList.size() > 0 && filesList.size() <= 2

                        if (onlyTestCompileJenkinsfile) {
                            echo "‚è≠Ô∏è Only pipeline/JenkinsFileTestCompile related files were changed. Skipping pipeline execution."
                            env.DESCRIPTION = "Pipeline Skipped - Only JenkinsFileTestCompile files changed"
                            updateCommitStatus(REPOSITORY_NAME, COMMIT_INPROGRESS_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)
                            
                            echo "‚úÖ Pipeline execution aborted successfully. Commit marked as success."
                            currentBuild.result = ABORTED
                            return
                        } else {
                            echo "‚úÖ Pipeline will continue - Changes detected in other files or multiple files changed."
                            currentBuild.result = SUCCESS
                        }
                    } catch (Exception e) {
                        echo "‚ùå Error in pipeline skip condition check: ${e.getMessage()}"            
                        env.DESCRIPTION = "Pipeline Check Failed"
                        updateCommitStatus(REPOSITORY_NAME, COMMIT_INPROGRESS_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)
                        currentBuild.result = FAILED
                        error("Failed to check pipeline skip condition: ${e.getMessage()}")
                    }
                }
            }
        }
        stage('Build Environment') { // MARK: Build Environment
            when {
                expression {
                    currentBuild.result == SUCCESS
                }
            }
            steps {
                container('compiler') {
                    script {
                        withCredentials([sshUserPrivateKey(credentialsId: 'my-credentials', keyFileVariable: 'keyfile')]) {
                            try {
                                def rootDir = pwd()
                                def infoCommit = load "${rootDir}/pipelines/utils/infoCommits.groovy"

                                sh "GIT_SSH_COMMAND=\"ssh -i ${keyfile} -o \"UserKnownHostsFile=/dev/null\" -o \"StrictHostKeyChecking=no\"\" git clone ${GIT_URL} ${REPOSITORY_NAME}"

                                def commitInfoTemplate = infoCommit.generateCommitInfo("${env.GITHUB_URL}/${env.GITHUB_ORG}", null, REPOSITORY_NAME, true, env.REPOSITORY_NAME)
                                env.COMMIT_INFO_TEMPLATE = "${commitInfoTemplate}"
                                echo "${env.COMMIT_INFO_TEMPLATE}"

                                env.DESCRIPTION = "Build Environment"
                                echo "--------------- ${env.DESCRIPTION} ---------------"
                                updateCommitStatus(REPOSITORY_NAME, COMMIT_INPROGRESS_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)
                                dir(REPOSITORY_NAME) {
                                    sh "git checkout ${GIT_COMMIT}"
                                    env.DESCRIPTION = "Build Environment"
                                    echo "--------------- ${env.DESCRIPTION} ---------------"
                                    updateCommitStatus(REPOSITORY_NAME, COMMIT_INPROGRESS_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)

                                    def lastRelease = getLatestReleaseWithPrefix("${GITHUB_ORG}/etendo_core", env.GITHUB_TOKEN, env.RELEASE_PREFIX)
                                    echo "Latest release with prefix '${env.RELEASE_PREFIX}': ${lastRelease}"

                                    sh """
                                    echo "\n
                                    allow.root=true
                                    nexusUser=${NEXUS_USER}
                                    nexusPassword=${NEXUS_PASSWORD}
                                    githubUser=${GITHUB_USER}
                                    githubToken=${GITHUB_TOKEN}
                                    test.bbdd.driver=org.postgresql.Driver
                                    test.bbdd.url=jdbc:postgresql://localhost:${BBDD_PORT}
                                    test.bbdd.sid=${BBDD_SID}
                                    test.bbdd.systemUser=${BBDD_SYSTEMUSER}
                                    test.bbdd.systemPassword=${BBDD_SYSTEMPASS}
                                    test.bbdd.user=${BBDD_USER}
                                    test.bbdd.password=${BBDD_PASSWORD}
                                    org.gradle.daemon=false
                                    org.gradle.jvmargs=-Dfile.encoding=UTF-8
                                    etendoCoreVersion=${lastRelease}" > ./gradle.properties
                                    """
                                }
                                currentBuild.result = SUCCESS
                            } catch (Exception e) {
                                echo 'Exception occurred: ' + e.toString()
                                env.DESCRIPTION = "Build Environment Failed"
                                echo "--------------- ${env.DESCRIPTION} ---------------"
                                currentBuild.result = FAILED
                                env.STATUS_TEST = FAILED
                                error(env.DESCRIPTION)
                            }
                        }
                    }
                }
            }
        }
        stage('Run EtendoPluginSOSTests Test Suite') { // MARK: Run EtendoPluginSOSTests Test Suite
            when {
                expression { currentBuild.result == SUCCESS }
            }
            steps {
                container('compiler') {
                    script {
                        withCredentials([sshUserPrivateKey(credentialsId: 'my-credentials', keyFileVariable: 'keyfile')]) {
                            def suiteName = "EtendoPluginSOSTests"
                            try {
                                env.DESCRIPTION = "Running ${suiteName}"
                                echo "--------------- ${env.DESCRIPTION} ---------------"
                                updateCommitStatus(REPOSITORY_NAME, COMMIT_INPROGRESS_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)
                                dir(REPOSITORY_NAME) {
                                    sh "./gradlew test --tests \"com.etendoerp.gradle.tests.${suiteName}\" --info"
                                    sh "mv build/jacoco/test.exec build/jacoco/test1.exec"
                                    echo "--------------- ${suiteName} Successful ---------------"
                                }
                                currentBuild.result = SUCCESS
                            } catch (Exception e) {
                                def currentFailed = env.FAILED_SUITES ?: ""
                                env.FAILED_SUITES = currentFailed.isEmpty() ? "${suiteName}" : "${currentFailed}, ${suiteName}"
                                env.STATUS_TEST = UNSTABLE
                                echo 'Exception occurred: ' + e.toString()
                                env.DESCRIPTION = "Failed ${suiteName}"
                                echo "--------------- ${env.DESCRIPTION} ---------------"
                                currentBuild.result = UNSTABLE
                                unstable(env.DESCRIPTION)
                            } finally {
                                publishHTML([
                                    allowMissing: true,
                                    alwaysLinkToLastBuild: false,
                                    keepAll: true,
                                    reportDir: "${REPOSITORY_NAME}/build/spock-reports/",
                                    reportFiles: '*.html',
                                    reportName: 'PLUGIN SOS TESTS REPORT',
                                    reportTitles: ''
                                ])
                                sh "rm -rf ${REPOSITORY_NAME}/build/spock-reports/"
                            }
                        }
                    }
                }
            }
        }
        stage('Run EtendoPluginPreReleaseTests1 Test Suite') { // MARK: Run EtendoPluginPreReleaseTestsPart1 Test Suite
            when {
                allOf {
                    expression { currentBuild.result == SUCCESS || currentBuild.result == UNSTABLE }
                    anyOf {
                        branch 'main'
                        branch 'develop'
                        expression { return env.GIT_BRANCH.startsWith("release/") }
                    }
                }
            }
            steps {
                container('compiler') {
                    script {
                        withCredentials([sshUserPrivateKey(credentialsId: 'my-credentials', keyFileVariable: 'keyfile')]) {
                            def suiteName = "EtendoPluginPreReleaseTestsPart1"
                            try {
                                env.DESCRIPTION = "Running ${suiteName}"
                                echo "--------------- ${env.DESCRIPTION} ---------------"
                                updateCommitStatus(REPOSITORY_NAME, COMMIT_INPROGRESS_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)
                                dir(REPOSITORY_NAME) {
                                    sh "./gradlew test --tests \"com.etendoerp.gradle.tests.${suiteName}\" --info"
                                    sh "mv build/jacoco/test.exec build/jacoco/test2.exec"
                                    echo "--------------- ${suiteName} Successful ---------------"
                                }
                                currentBuild.result = SUCCESS
                            } catch (Exception e) {
                                def currentFailed = env.FAILED_SUITES ?: ""
                                env.FAILED_SUITES = currentFailed.isEmpty() ? "${suiteName}" : "${currentFailed}, ${suiteName}"
                                env.STATUS_TEST = UNSTABLE
                                echo 'Exception occurred: ' + e.toString()
                                env.DESCRIPTION = "Failed ${suiteName}"
                                echo "--------------- ${env.DESCRIPTION} ---------------"
                                currentBuild.result = UNSTABLE
                                unstable(env.DESCRIPTION)
                            } finally {
                                publishHTML([
                                    allowMissing: true,
                                    alwaysLinkToLastBuild: false,
                                    keepAll: true,
                                    reportDir: "${REPOSITORY_NAME}/build/spock-reports/",
                                    reportFiles: '*.html',
                                    reportName: 'PLUGIN PRE-RELEASE PART 1 TESTS REPORT',
                                    reportTitles: ''
                                ])
                                sh "rm -rf ${REPOSITORY_NAME}/build/spock-reports/"
                            }
                        }
                    }
                }
            }
        }
        stage('Run EtendoPluginPreReleaseTests2 Test Suite') { // MARK: Run EtendoPluginPreReleaseTestsPart2 Test Suite
            when {
                allOf {
                    expression { currentBuild.result == SUCCESS || currentBuild.result == UNSTABLE }
                    anyOf {
                        branch 'main'
                        branch 'develop'
                        expression { return env.GIT_BRANCH.startsWith("release/") }
                    }
                }
            }
            steps {
                container('compiler') {
                    script {
                        withCredentials([sshUserPrivateKey(credentialsId: 'my-credentials', keyFileVariable: 'keyfile')]) {
                            def suiteName = "EtendoPluginPreReleaseTestsPart2"
                            try {
                                env.DESCRIPTION = "Running ${suiteName}"
                                echo "--------------- ${env.DESCRIPTION} ---------------"
                                updateCommitStatus(REPOSITORY_NAME, COMMIT_INPROGRESS_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)
                                dir(REPOSITORY_NAME) {
                                    sh "./gradlew test --tests \"com.etendoerp.gradle.tests.${suiteName}\" --info"
                                    sh "mv build/jacoco/test.exec build/jacoco/test3.exec"
                                    echo "--------------- ${suiteName} Successful ---------------"
                                }
                                currentBuild.result = SUCCESS
                            } catch (Exception e) {
                                def currentFailed = env.FAILED_SUITES ?: ""
                                env.FAILED_SUITES = currentFailed.isEmpty() ? "${suiteName}" : "${currentFailed}, ${suiteName}"
                                env.STATUS_TEST = UNSTABLE
                                echo 'Exception occurred: ' + e.toString()
                                env.DESCRIPTION = "Failed ${suiteName}"
                                echo "--------------- ${env.DESCRIPTION} ---------------"
                                currentBuild.result = UNSTABLE
                                unstable(env.DESCRIPTION)
                            } finally {
                                publishHTML([
                                    allowMissing: true,
                                    alwaysLinkToLastBuild: false,
                                    keepAll: true,
                                    reportDir: "${REPOSITORY_NAME}/build/spock-reports/",
                                    reportFiles: '*.html',
                                    reportName: 'PLUGIN PRE-RELEASE PART 2 TESTS REPORT',
                                    reportTitles: ''
                                ])
                            }
                        }
                    }
                }
            }
        }
        stage('Generate Coverage Report') { // MARK: Generate Coverage Report
            when {
                expression { currentBuild.result == SUCCESS && env.STATUS_TEST == SUCCESS }
            }
            steps {
                container("compiler") {
                    script {
                        try {
                            dir(REPOSITORY_NAME) {
                                env.DESCRIPTION = "Generating Coverage Report"
                                echo "--------------- ${env.DESCRIPTION} ---------------"
                                updateCommitStatus(REPOSITORY_NAME, COMMIT_INPROGRESS_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)
                                echo "---------------------- Run jacocoRootReport ----------------------"
                                env.JACOCO_REPORT_EXISTS = FALSE
                                sh """
                                ./gradlew jacocoRootReport --info
                                """
                                env.JACOCO_REPORT = "build/reports/jacoco/jacocoRootReport/jacocoRootReport.xml"

                                if (fileExists("${JACOCO_REPORT}")) {
                                    echo "---------------------- Jacoco Report Found ----------------------"
                                    env.JACOCO_REPORT_EXISTS = TRUE
                                }
                            }
                        } catch (Exception e) {
                            echo 'Exception occurred: ' + e.toString()
                            env.STATUS_TEST = UNSTABLE
                            env.DESCRIPTION = "Failed to Generate Coverage Report"
                            echo "--------------- ${env.DESCRIPTION} ---------------"
                            currentBuild.result = UNSTABLE
                            error(env.DESCRIPTION)
                        }

                    }
                }
            }
        }

        stage('Run SonarQube Analysis') { // MARK: Run SonarQube Analysis
            when {
                expression { currentBuild.result == SUCCESS && env.JACOCO_REPORT_EXISTS == TRUE && env.STATUS_TEST == SUCCESS }
            }
            steps {
                container("compiler") {
                    script {
                        try {
                            env.DESCRIPTION = "Running SonarQube Analysis"
                            echo "--------------- ${env.DESCRIPTION} ---------------"
                            updateCommitStatus(REPOSITORY_NAME, COMMIT_INPROGRESS_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)
                            echo "---------------------- Installing SonarQube Scanner ----------------------"
                            sh """
                            apt-get update && apt-get install -y wget unzip
                            wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-${SONAR_VERSION}-linux.zip
                            unzip sonar-scanner-cli-${SONAR_VERSION}-linux.zip
                            """
                            env.PATH = "${env.PATH}:${WORKSPACE}/sonar-scanner-${SONAR_VERSION}-linux/bin"
                            dir(REPOSITORY_NAME) {
                                def sonarSources = "./src/main/groovy"
                                def projectKey = sh(script: "grep 'sonar.projectKey' sonar-project.properties | cut -d '=' -f2", returnStdout: true).trim()
                                env.PROJECT_KEY = "${projectKey}"
                                echo "SonarQube Project Key: ${env.PROJECT_KEY}"

                                echo "---------------------- Running SonarQube ----------------------"
                                sh """
                                ${WORKSPACE}/sonar-scanner-${SONAR_VERSION}-linux/bin/sonar-scanner -X \
                                    -Dsonar.projectKey=${env.PROJECT_KEY} \
                                    -Dsonar.sources=${sonarSources} \
                                    -Dsonar.host.url=${SONAR_SERVER} \
                                    -Dsonar.login=${SONAR_TOKEN} \
                                    -Dsonar.branch.name=${GIT_BRANCH} \
                                    -Dsonar.projectVersion=${GIT_COMMIT} \
                                    -Dsonar.scm.revision=${GIT_COMMIT} \
                                    -Dsonar.java.coveragePlugin=jacoco \
                                    -Dsonar.coverage.jacoco.xmlReportPaths=${JACOCO_REPORT}
                                """

                                echo "---------------------- Getting SonarQube Report URL ----------------------"
                                def branchName = URLEncoder.encode(GIT_BRANCH, 'UTF-8')
                                def projectUrl = "${SONAR_SERVER}/dashboard?id=${env.PROJECT_KEY}&branch=${branchName}"
                                env.PROJECT_URL = "${projectUrl}"
                                echo "Sonar Project URL: ${PROJECT_URL}"

                                echo "---------------------- SonarQube Analysis Successful ----------------------"
                            }
                        } catch (Exception e) {
                            echo 'Exception occurred: ' + e.toString()
                            env.STATUS_TEST = UNSTABLE
                            env.DESCRIPTION = "SonarQube Analysis Failed"
                            echo "--------------- ${env.DESCRIPTION} ---------------"
                            currentBuild.result = FAILED
                            error(env.DESCRIPTION)
                        }
                    }
                }
            }
        }
        stage('Compare Coverage Results') { // MARK: - Compare Coverage Results
            when {
                expression {
                    currentBuild.result == SUCCESS && env.STATUS_TEST == SUCCESS && env.JACOCO_REPORT_EXISTS == TRUE &&
                    !(env.GIT_BRANCH == env.MAIN_BRANCH || env.GIT_BRANCH.startsWith("release/"))
                }
            }
            steps {
                container("compiler") {
                    script {
                        try {
                            env.DESCRIPTION = "Comparing Coverage Results"
                            echo "--------------- ${env.DESCRIPTION} ---------------"
                            updateCommitStatus(REPOSITORY_NAME, COMMIT_INPROGRESS_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)
                            echo "SonarQube Project Key: ${env.PROJECT_KEY}"
                            def branchCurrent = URLEncoder.encode(GIT_BRANCH, 'UTF-8')
                            def projectUrl = "${SONAR_SERVER}/dashboard?id=${env.PROJECT_KEY}&branch=${branchCurrent}"
                            env.PROJECT_URL = "${projectUrl}"
                            echo "Sonar Project URL: ${PROJECT_URL}"
                            def branchCompare = env.MAIN_BRANCH
                            env.COMPARE_COVERAGE_STATUS = SUCCESS
                            if (env.GIT_BRANCH.contains("-Y")) {
                                def yearCommitBranch = (GIT_BRANCH =~ /-Y(\d{2})/)?.find() ? (GIT_BRANCH =~ /-Y(\d{2})/)[0][1] : null
                                def yearBackportBranch = (env.BACKPORT_BRANCH =~ /release\/(\d{2})\./)?.find() ? (env.BACKPORT_BRANCH =~ /release\/(\d{2})\./)[0][1] : null
                                if (yearCommitBranch && yearBackportBranch) {
                                    if (yearCommitBranch == yearBackportBranch) {
                                        echo "The year of GIT_BRANCH (${yearCommitBranch}) and the year of BACKPORT_BRANCH (${yearBackportBranch}) match."
                                        echo "This means the branch is a backport branch."
                                        branchCompare = env.env.BACKPORT_BRANCH
                                    } else {
                                        echo "The year of GIT_BRANCH (${yearCommitBranch}) and the year of BACKPORT_BRANCH (${yearBackportBranch}) do NOT match."
                                    }
                                } else {
                                    echo "Could not extract the year from GIT_BRANCH or env.BACKPORT_BRANCH."
                                }
                            }
                            echo "-------------------------- Comparing Coverage with ${branchCompare} Branch --------------------------"

                            def rootDir = pwd()
                            def sonarUtils = load "${rootDir}/pipelines/utils/sonarUtils.groovy"

                            // Only check commit on PR branches
                            def checkCommitCurrent = GIT_BRANCH.startsWith('feature/') || GIT_BRANCH.startsWith('hotfix/') || GIT_BRANCH.startsWith('epic/') || GIT_BRANCH.startsWith('prerelease/')
                            echo "Check commit for current branch (${GIT_BRANCH}): ${checkCommitCurrent}"
                            def coverageCurrent = sonarUtils.getCoverageWithRetry(
                                GIT_BRANCH,
                                checkCommitCurrent,
                                env.PROJECT_KEY,
                                SONAR_TOKEN,
                                SONAR_SERVER,
                                env.GIT_COMMIT
                            )
                            def coverageOriginBranch = sonarUtils.getCoverageWithRetry(
                                branchCompare,
                                false,
                                env.PROJECT_KEY,
                                SONAR_TOKEN,
                                SONAR_SERVER,
                                null
                            )

                            echo "Current branch (${env.GIT_BRANCH}) coverage: ${coverageCurrent}%"
                            echo "${branchCompare} branch coverage: ${coverageOriginBranch}%"
                            if (coverageCurrent < coverageOriginBranch) {
                                env.ERROR_MESSAGE = "Coverage (${coverageCurrent}%) is lower than ${branchCompare} branch (${coverageOriginBranch}%)"
                                echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
                                currentBuild.result = UNSTABLE
                                env.COMPARE_COVERAGE_STATUS = FAILED
                                unstable(env.ERROR_MESSAGE)
                            } else {
                                echo "-------------------------- Coverage is OK --------------------------"
                                currentBuild.result = SUCCESS
                            }
                        } catch (Exception e) {
                            echo "Exception occurred: " + e.toString()
                            env.ERROR_MESSAGE = "Comparing Coverage Results Failed"
                            echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
                            currentBuild.result = UNSTABLE
                            error(env.ERROR_MESSAGE)
                        }
                    }
                }
            }
        }
        stage('Run Deploy Snapshot') { // MARK: Run Deploy Snapshot
            when {
                branch 'develop'
                expression { currentBuild.result == SUCCESS && env.STATUS_TEST == SUCCESS }
            }
            steps {
                container('compiler') {
                    script {
                        try {
                            withCredentials([sshUserPrivateKey(credentialsId: 'my-credentials', keyFileVariable: 'keyfile')]) {
                                withCredentials([usernamePassword(credentialsId: "etendo_bot_credentials", passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
                                    env.DESCRIPTION = "Running Deploy Snapshot"
                                    updateCommitStatus(REPOSITORY_NAME, COMMIT_FAILED_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)
                                    dir(REPOSITORY_NAME) {
                                        echo "--------------- ${env.DESCRIPTION} ---------------"
                                        sh "./gradlew publish --info"
                                    }
                                }
                            }
                        } catch (Exception e) {
                            echo 'Exception occurred: ' + e.toString()
                            echo '....FAILED DEPLOY SNAPSHOT....'
                            currentBuild.result = FAILED
                            env.DESCRIPTION = "Failed Deploy Snapshot"
                            echo "--------------- ${env.DESCRIPTION} ---------------"
                            error('Failed Deploy Snapshot')
                        }
                    }
                }
            }
        }
    }

    post { // MARK: Post Actions
        success {
            script {
                echo "---------------- DONE ----------------"
                env.DESCRIPTION = "Plugin Tests Successful"
                updateCommitStatus(REPOSITORY_NAME, COMMIT_SUCCESS_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)
            }
        }
        unstable {
            script {
                updateCommitStatus(REPOSITORY_NAME, COMMIT_FAILED_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)
                def mailSubject = ""
                def bodyMessageError = ""
                def moreInfo = ""

                if (env.TEST_STATUS == UNSTABLE) {
                    mailSubject = "Failed Tests"
                    bodyMessageError = "<p><strong>Failed Test Suites:</strong> ${env.FAILED_SUITES}</p>"
                    moreInfo = "<p>To more information on the failing run visit <a href='${env.BUILD_URL}'>Jenkins Build</a>.</p>"
                } else if (env.COMPARE_COVERAGE_STATUS == FAILED) {
                    mailSubject = "Coverage Decreased"
                    bodyMessageError = "<p><strong>${env.ERROR_MESSAGE}</strong></p>"
                    moreInfo = "<p>To more information on the failing run visit <a href='${env.PROJECT_URL}'>SonarQube Report</a> and <a href='${env.BUILD_URL}'>Jenkins Build</a>.</p>"
                }
                env.EMAIL_SUBJECT = mailSubject
                env.BODY_MESSAGE_ERROR = bodyMessageError
                env.MORE_INFO = moreInfo
            }
            mail to: EMAIL_ADDRESS,
                subject: "‚ö†Ô∏è ${env.EMAIL_SUBJECT} - ${currentBuild.fullDisplayName}",
                mimeType: "text/html",
                body:  """
                    <html>
                    <head>
                        <style>
                            body { font-family: 'Arial', sans-serif; }
                            .header { font-size: 16px; font-weight: bold; color: #333; }
                        </style>
                    </head>
                    <body>
                        <p>__________________________________________________________</p>

                        <h2 class="header">‚ö†Ô∏è ${env.EMAIL_SUBJECT} ‚ö†Ô∏è</h2>

                        ${env.BODY_MESSAGE_ERROR}

                        ${env.COMMIT_INFO_TEMPLATE}

                        ${env.MORE_INFO}

                        <p class="footer"><em>Best regards,<br>#EtendoBot ü§ñ</em></p>
                        <p>__________________________________________________________</p>
                    </body>
                    </html>
                """
        }
        failure {
            script {
                updateCommitStatus(REPOSITORY_NAME, COMMIT_FAILED_STATUS, env.DESCRIPTION, ACCESS_TOKEN, GIT_COMMIT, BUILD_URL, CONTEXT_BUILD)
            }
            mail to: EMAIL_ADDRESS,
                subject: "üö´ ${env.DESCRIPTION} - ${currentBuild.fullDisplayName}",
                mimeType: "text/html",
                body:  """
                    <html>
                    <head>
                        <style>
                            body { font-family: 'Arial', sans-serif; }
                            .header { font-size: 16px; font-weight: bold; color: #333; }
                        </style>
                    </head>
                    <body>
                        <p>__________________________________________________________</p>

                        <h2 class="header">üö´ ${env.DESCRIPTION} üö´</h2>

                        ${env.COMMIT_INFO_TEMPLATE}

                        <p>To more information on the failing run visit <a href='${env.BUILD_URL}'>Jenkins Build</a></p>

                        <p class="footer"><em>Best regards,<br>#EtendoBot ü§ñ</em></p>
                        <p>__________________________________________________________</p>
                    </body>
                    </html>
                """
        }
    }
}
